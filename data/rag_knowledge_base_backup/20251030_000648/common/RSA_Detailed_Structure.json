{
  "algorithm": "RSA",
  "type": "asymmetric_encryption_signature",
  "quantum_vulnerable": true,
  "shor_algorithm_impact": "Polynomial time factorization breaks RSA completely",
  "detailed_structure": [
    {
      "component": "Key_Generation",
      "mathematical_operations": [
        "1. Generate two large random primes p and q (typically 1024 bits each for 2048-bit RSA)",
        "2. Compute modulus n = p × q (2048-4096 bits)",
        "3. Compute Euler's totient φ(n) = (p-1)(q-1)",
        "4. Choose public exponent e, typically 65537 (0x10001), where gcd(e, φ(n)) = 1",
        "5. Compute private exponent d ≡ e^(-1) mod φ(n) using Extended Euclidean Algorithm",
        "6. Optionally compute CRT parameters: dP = d mod (p-1), dQ = d mod (q-1), qInv = q^(-1) mod p"
      ],
      "code_patterns": {
        "source_code": [
          "Prime generation: Miller-Rabin primality test iterations",
          "Large integer multiplication (BigInteger, GMP, OpenSSL BIGNUM)",
          "Euler totient: (p-1) * (q-1) computation",
          "Extended GCD for modular inverse",
          "Public exponent constant 65537 or variable selection",
          "CRT parameter computation using modulo operations"
        ],
        "assembly": [
          "Multi-precision multiplication loops",
          "Division for modulo operations (or Barrett/Montgomery reduction)",
          "Probabilistic primality testing loops",
          "Extended GCD recursive/iterative algorithm",
          "Memory allocation for large integers (malloc/new)"
        ],
        "memory_structure": [
          "p, q stored separately (security-critical, should be cleared)",
          "n stored in public key structure",
          "d stored in private key (highly sensitive)",
          "e typically small (65537 fits in 32 bits)",
          "CRT parameters dP, dQ, qInv in private key for optimization"
        ]
      },
      "detection_indicators": [
        "Two-prime factorization structure (n = p × q)",
        "Modulus size: 1024, 2048, 3072, 4096 bits",
        "Small public exponent (65537 most common)",
        "Extended GCD algorithm implementation",
        "Euler totient function computation"
      ]
    },
    {
      "component": "Encryption",
      "mathematical_operations": [
        "1. Input: plaintext message m (m < n)",
        "2. Padding: PKCS#1 v1.5 or OAEP (Optimal Asymmetric Encryption Padding)",
        "3. Compute ciphertext c = m^e mod n using modular exponentiation",
        "4. Output: ciphertext c (same bit length as n)"
      ],
      "code_patterns": {
        "source_code": [
          "Padding scheme implementation (PKCS1, OAEP with SHA hash)",
          "Modular exponentiation: square-and-multiply or window method",
          "Message size check: m < n",
          "Random padding generation for OAEP",
          "MGF1 mask generation function (for OAEP)"
        ],
        "assembly": [
          "Exponentiation loop with squaring",
          "Conditional multiplication based on exponent bits",
          "Modular reduction after each operation",
          "Padding byte operations and XOR (OAEP)",
          "SHA hash computation (for OAEP)"
        ],
        "optimization_patterns": [
          "Montgomery multiplication for fast modular reduction",
          "Precomputed Montgomery constants (R, R^-1, n')",
          "Sliding window exponentiation (4-6 bit windows)",
          "Precomputed powers of base for window method"
        ]
      },
      "detection_indicators": [
        "Exponentiation with small exponent (e = 65537)",
        "PKCS#1 padding: starts with 0x00 0x02 for encryption",
        "OAEP: MGF1 mask generation with SHA-1/SHA-256",
        "Modular reduction by large modulus n",
        "Output same size as modulus (2048/4096 bits)"
      ]
    },
    {
      "component": "Decryption",
      "mathematical_operations": [
        "1. Input: ciphertext c",
        "2. Without CRT: m = c^d mod n (slow, uses full private exponent)",
        "3. With CRT optimization:",
        "   - m1 = c^dP mod p",
        "   - m2 = c^dQ mod q",
        "   - h = (qInv × (m1 - m2)) mod p",
        "   - m = m2 + h × q",
        "4. Remove padding (PKCS#1 or OAEP)",
        "5. Output: plaintext message m"
      ],
      "code_patterns": {
        "source_code": [
          "CRT implementation: two separate exponentiations",
          "CRT recombination using qInv",
          "Large exponent d (same bit length as n)",
          "Padding validation and removal",
          "Timing attack countermeasures (constant-time operations)",
          "Blinding: multiply by random r^e before decryption"
        ],
        "assembly": [
          "Two parallel modular exponentiations (m1, m2)",
          "Modulo operations with primes p and q (not public modulus n)",
          "CRT recombination: subtraction, multiplication, addition",
          "Timing-constant comparison for padding validation",
          "Random blinding value generation and multiplication"
        ],
        "security_patterns": [
          "RSA blinding to prevent timing attacks",
          "Constant-time padding validation",
          "Key material cleared from memory after use",
          "Side-channel resistant implementations"
        ]
      },
      "detection_indicators": [
        "CRT: two exponentiations with different moduli (p, q)",
        "Private exponent d is large (same size as n)",
        "Padding removal: check for 0x00 0x02 prefix",
        "Blinding: multiplication with random value before exponentiation",
        "~4x speedup with CRT vs. without"
      ]
    },
    {
      "component": "Signature_Generation",
      "mathematical_operations": [
        "1. Hash message: h = Hash(m) using SHA-256/SHA-512",
        "2. Apply padding: PKCS#1 v1.5 or PSS (Probabilistic Signature Scheme)",
        "3. Compute signature s = h^d mod n (uses private key)",
        "4. Output: signature s"
      ],
      "code_patterns": {
        "source_code": [
          "Hash function: SHA-256, SHA-384, SHA-512",
          "PKCS#1 v1.5 padding with DigestInfo (0x00 0x01 0xFF...)",
          "PSS: salt generation, MGF1 mask generation",
          "Private key exponentiation (same as decryption)",
          "Signature encoding (DER, raw bytes)"
        ],
        "assembly": [
          "Hash computation (SHA rounds)",
          "Padding construction with 0xFF bytes",
          "Modular exponentiation with private exponent d or CRT",
          "Salt generation (randomness) for PSS",
          "Signature formatting and output"
        ]
      },
      "detection_indicators": [
        "Message hashing before signing",
        "PKCS#1 v1.5: 0x00 0x01 0xFF... padding",
        "PSS: salt and MGF1 mask generation",
        "Signature same size as modulus (2048/4096 bits)",
        "Uses private key (d or CRT parameters)"
      ]
    },
    {
      "component": "Signature_Verification",
      "mathematical_operations": [
        "1. Compute h' = s^e mod n (uses public key)",
        "2. Extract hash from padded h'",
        "3. Hash message: h = Hash(m)",
        "4. Compare h' == h",
        "5. Return valid/invalid"
      ],
      "code_patterns": {
        "source_code": [
          "Public key exponentiation (fast, e = 65537)",
          "Padding verification (PKCS#1 or PSS)",
          "Hash comparison (constant-time)",
          "No secret key operations (public operation)",
          "Invalid signature rejection"
        ],
        "assembly": [
          "Fast exponentiation with small exponent",
          "Padding format validation",
          "Hash comparison loop",
          "No CRT (public key has no p, q)",
          "Return boolean result"
        ]
      },
      "detection_indicators": [
        "Fast operation (small public exponent)",
        "Padding verification code",
        "Hash comparison",
        "Public key usage only (n, e)",
        "Boolean return (valid/invalid)"
      ]
    },
    {
      "component": "Mathematical_Primitives",
      "primitives": [
        {
          "name": "Modular_Exponentiation",
          "algorithm": "Square-and-multiply (binary method)",
          "pseudocode": [
            "result = 1",
            "base = base mod n",
            "for each bit in exponent (from MSB to LSB):",
            "  result = (result * result) mod n  // square",
            "  if bit == 1:",
            "    result = (result * base) mod n  // multiply",
            "return result"
          ],
          "detection": "Loop with squaring every iteration, conditional multiply"
        },
        {
          "name": "Montgomery_Multiplication",
          "algorithm": "REDC (Montgomery Reduction)",
          "pseudocode": [
            "// Compute a*b mod n using Montgomery form",
            "// R = 2^k where k is bit length of n",
            "// n' = -n^(-1) mod R (precomputed)",
            "function MontMul(a, b, n, n', R):",
            "  t = a * b",
            "  m = (t * n') mod R",
            "  u = (t + m*n) / R",
            "  if u >= n: u = u - n",
            "  return u"
          ],
          "detection": "Two multiplications, one shift (divide by R), conditional subtraction, no division instruction"
        },
        {
          "name": "Extended_Euclidean_Algorithm",
          "algorithm": "Compute modular inverse for d ≡ e^(-1) mod φ(n)",
          "pseudocode": [
            "function ExtGCD(a, b):",
            "  if b == 0: return (a, 1, 0)",
            "  (gcd, x1, y1) = ExtGCD(b, a mod b)",
            "  x = y1",
            "  y = x1 - (a // b) * y1",
            "  return (gcd, x, y)"
          ],
          "detection": "Recursive or iterative GCD with coefficient tracking"
        },
        {
          "name": "Miller_Rabin_Primality_Test",
          "algorithm": "Probabilistic prime testing",
          "pseudocode": [
            "// Test if n is prime with k rounds",
            "function MillerRabin(n, k):",
            "  Write n-1 as 2^r * d",
            "  for i in 1..k:",
            "    a = random(2, n-2)",
            "    x = a^d mod n",
            "    if x == 1 or x == n-1: continue",
            "    for j in 1..r-1:",
            "      x = x^2 mod n",
            "      if x == n-1: break",
            "    if x != n-1: return composite",
            "  return probably_prime"
          ],
          "detection": "Multiple rounds (k=20-50), random base selection, modular exponentiation, squaring loop"
        }
      ]
    },
    {
      "component": "Common_Constants_and_Values",
      "constants": [
        {"value": "65537", "hex": "0x10001", "usage": "Most common RSA public exponent e"},
        {"value": "3", "hex": "0x03", "usage": "Smallest valid public exponent (less common)"},
        {"value": "17", "hex": "0x11", "usage": "Alternative small public exponent"},
        {"value": "1024", "usage": "Minimum key size (deprecated, insecure)"},
        {"value": "2048", "usage": "Current standard key size"},
        {"value": "3072", "usage": "High security key size"},
        {"value": "4096", "usage": "Maximum common key size"},
        {"value": "0x00 0x01 0xFF 0xFF...", "usage": "PKCS#1 v1.5 signature padding prefix"},
        {"value": "0x00 0x02 [random] 0x00", "usage": "PKCS#1 v1.5 encryption padding"}
      ]
    },
    {
      "component": "Attack_Vulnerabilities",
      "quantum_attacks": {
        "shor_algorithm": "Factors n into p×q in polynomial time O((log n)³), completely breaking RSA",
        "impact": "All RSA key sizes (1024-4096 bits) broken with sufficiently large quantum computer",
        "timeline": "Estimated 10-30 years until quantum computers can break RSA-2048"
      },
      "classical_attacks": [
        "Factorization: GNFS algorithm, time complexity sub-exponential",
        "Timing attacks: measure decryption time to extract private key bits",
        "Padding oracle attacks: Bleichenbacher attack on PKCS#1 v1.5",
        "Side-channel: power analysis, electromagnetic radiation",
        "Small exponent attacks: if e=3 and no padding, cube root attack"
      ]
    },
    {
      "component": "Detection_Summary",
      "high_confidence_indicators": [
        "Modular exponentiation with 1024-4096 bit integers",
        "Public exponent 65537 (0x10001) constant",
        "Two-prime multiplication (p×q) for modulus",
        "Euler's totient φ(n) = (p-1)(q-1) computation",
        "CRT parameters: dP, dQ, qInv",
        "PKCS#1 padding patterns (0x00 0x01 or 0x00 0x02)",
        "Extended GCD for modular inverse",
        "Miller-Rabin primality testing"
      ],
      "code_structure_indicators": [
        "Key generation: prime generation, totient, inverse computation",
        "Encryption: small exponent exponentiation, PKCS#1/OAEP padding",
        "Decryption: large exponent exponentiation or CRT, padding removal",
        "Signature: hash then exponentiate with private key",
        "Verification: exponentiate with public key then compare hash"
      ],
      "library_function_names": [
        "RSA_generate_key, RSA_public_encrypt, RSA_private_decrypt (OpenSSL)",
        "CryptGenKey(AT_KEYEXCHANGE), CryptEncrypt (Windows CryptoAPI)",
        "SecKeyCreateWithData, SecKeyCreateEncryptedData (macOS/iOS)",
        "generateKeyPair('rsa'), publicEncrypt, privateDecrypt (Node.js)",
        "Cipher.getInstance('RSA/ECB/PKCS1Padding') (Java)"
      ]
    }
  ]
}
