{
  "signatures": [
    {
      "type": "assembly_instruction",
      "category": "ARM_Crypto_Extensions",
      "content": "ARMv8 Crypto Extensions: AESE (AES encrypt), AESD (AES decrypt), AESMC (AES mix columns), AESIMC (AES inverse mix columns). Hardware-accelerated AES on ARM. AES-256 recommended for quantum resistance.",
      "confidence": 1.0,
      "source": "ARMv8_Crypto_Extensions",
      "keywords": ["AESE", "AESD", "AESMC", "AESIMC", "aese.8", "aesd.8"],
      "architectures": ["ARMv8", "ARMv8-A", "ARM64"],
      "severity": "low",
      "note": "AES symmetric crypto is relatively quantum-safe"
    },
    {
      "type": "assembly_instruction",
      "category": "ARM_SHA_Extensions",
      "content": "ARMv8 SHA Extensions: SHA1C, SHA1P, SHA1M, SHA1SU0, SHA1SU1 (SHA-1), SHA256H, SHA256H2, SHA256SU0, SHA256SU1 (SHA-256). SHA-1 is broken, prefer SHA-256 or SHA-3.",
      "confidence": 0.95,
      "source": "ARMv8_SHA_Instructions",
      "keywords": ["SHA1C", "SHA1P", "SHA1M", "SHA256H", "SHA256H2", "sha1c.32", "sha256h.32"],
      "architectures": ["ARMv8", "ARM64"],
      "severity": "medium",
      "note": "SHA-1 deprecated, use SHA-256+"
    },
    {
      "type": "crypto_library_call",
      "category": "ARM_mbedTLS",
      "content": "mbedTLS on ARM: bl mbedtls_rsa_public, bl mbedtls_ecdsa_sign, bl mbedtls_dhm_make_public. Branch-and-link to mbedTLS crypto functions indicates RSA/ECDSA/DH usage.",
      "confidence": 0.9,
      "source": "ARM_mbedTLS",
      "keywords": ["bl mbedtls_rsa", "bl mbedtls_ecdsa", "bl mbedtls_ecp", "bl mbedtls_dhm"],
      "architectures": ["ARM", "ARMv7", "ARMv8"],
      "severity": "high"
    },
    {
      "type": "crypto_library_call",
      "category": "ARM_WolfSSL",
      "content": "wolfSSL on ARM: bl wc_RsaPublicEncrypt, bl wc_ecc_sign_hash, bl wc_DhGenerateKeyPair. wolfSSL is common in ARM-based IoT/embedded devices.",
      "confidence": 0.85,
      "source": "ARM_WolfSSL",
      "keywords": ["bl wc_RsaPublicEncrypt", "bl wc_ecc", "bl wc_DhGenerateKeyPair"],
      "architectures": ["ARM", "ARMv7", "ARMv8"],
      "severity": "high"
    },
    {
      "type": "crypto_library_call",
      "category": "ARM_OpenSSL",
      "content": "OpenSSL on ARM: bl RSA_public_encrypt, bl ECDSA_sign, bl EC_KEY_generate_key. Standard OpenSSL crypto functions compiled for ARM.",
      "confidence": 0.9,
      "source": "ARM_OpenSSL",
      "keywords": ["bl RSA_public_encrypt", "bl ECDSA_sign", "bl EC_KEY_generate_key", "bl DH_compute_key"],
      "architectures": ["ARM", "ARMv7", "ARMv8"],
      "severity": "high"
    },
    {
      "type": "assembly_pattern",
      "category": "ARM_Modular_Multiplication",
      "content": "ARM modular multiplication patterns: UMULL (unsigned multiply long), UMLAL (unsigned multiply accumulate long) in loops with division. Indicates big integer arithmetic for RSA/DH.",
      "confidence": 0.75,
      "source": "ARM_BigInt_Crypto",
      "keywords": ["UMULL", "UMLAL", "SMULL", "SMLAL", "udiv loop"],
      "architectures": ["ARM", "ARMv7", "ARMv8"],
      "severity": "high",
      "note": "Likely RSA or DH implementation"
    },
    {
      "type": "assembly_pattern",
      "category": "ARM_ECC_Point_Operations",
      "content": "ARM ECC point operations: Field multiplication with reduction modulo prime. NEON SIMD instructions (VMUL, VADD, VSUB) processing curve coordinates.",
      "confidence": 0.7,
      "source": "ARM_ECC_Implementation",
      "keywords": ["VMUL.I32", "VADD.I64", "VSUB.I64", "point doubling", "point addition"],
      "architectures": ["ARMv7-NEON", "ARMv8"],
      "severity": "high"
    },
    {
      "type": "register_pattern",
      "category": "ARM_NEON_Crypto",
      "content": "ARM NEON crypto patterns: Q0-Q15 vector registers with VTBL (table lookup), VEXT (extract), VREV (reverse) for AES S-Box operations or ChaCha20.",
      "confidence": 0.75,
      "source": "ARM_NEON_Patterns",
      "keywords": ["VTBL", "VEXT", "VREV", "VEOR", "Q0-Q15"],
      "architectures": ["ARMv7-NEON", "ARMv8"],
      "severity": "low",
      "note": "Usually symmetric crypto (AES, ChaCha20)"
    },
    {
      "type": "crypto_constant",
      "category": "ARM_Crypto_Constants",
      "content": "Crypto constants in ARM: LDR with literal pool addresses pointing to RSA exponents (0x10001), ECC curve primes, or AES S-boxes.",
      "confidence": 0.8,
      "source": "ARM_Constant_Pool",
      "keywords": ["LDR r0, =0x10001", "LDR r1, =prime_table", "literal pool crypto"],
      "architectures": ["ARM", "ARMv7", "ARMv8"],
      "severity": "medium"
    },
    {
      "type": "assembly_instruction",
      "category": "ARM_TrustZone_Crypto",
      "content": "ARM TrustZone secure crypto: SMC (Secure Monitor Call) instructions accessing secure world crypto services. Indicates hardware-backed key storage.",
      "confidence": 0.85,
      "source": "ARM_TrustZone",
      "keywords": ["SMC", "smc #0", "bl trustzone_crypto", "secure world"],
      "architectures": ["ARMv7-A", "ARMv8-A"],
      "severity": "info",
      "note": "Check if using quantum-vulnerable algorithms in secure world"
    },
    {
      "type": "crypto_library_call",
      "category": "ARM_BoringSSL",
      "content": "BoringSSL on ARM: bl CRYPTO_chacha_20, bl RSA_sign_raw, bl ECDSA_sign_with_nonce. Google's BoringSSL crypto library on ARM devices.",
      "confidence": 0.8,
      "source": "ARM_BoringSSL",
      "keywords": ["bl CRYPTO_chacha_20", "bl RSA_sign_raw", "bl ECDSA_sign"],
      "architectures": ["ARM", "ARMv8"],
      "severity": "high"
    },
    {
      "type": "assembly_pattern",
      "category": "ARM_Thumb2_Crypto",
      "content": "Thumb-2 crypto patterns: 16-bit/32-bit mixed instructions in crypto loops. BL.W (wide branch) to crypto functions, IT (if-then) blocks for constant-time implementations.",
      "confidence": 0.7,
      "source": "ARM_Thumb2",
      "keywords": ["BL.W", "IT", "thumb2 crypto", "16-bit crypto loop"],
      "architectures": ["ARMv7-M", "Cortex-M"],
      "severity": "medium"
    },
    {
      "type": "assembly_instruction",
      "category": "ARM_CRC32",
      "content": "ARM CRC32 instructions: CRC32B, CRC32H, CRC32W, CRC32CB (CRC32 Castagnoli). Not cryptographic, used for checksums. Do not confuse with crypto hash functions.",
      "confidence": 0.9,
      "source": "ARM_CRC32",
      "keywords": ["CRC32B", "CRC32H", "CRC32W", "CRC32CB"],
      "architectures": ["ARMv8"],
      "severity": "safe",
      "note": "CRC is not cryptographic, used for error detection"
    },
    {
      "type": "assembly_pattern",
      "category": "ARM_Constant_Time_Patterns",
      "content": "ARM constant-time crypto: CSEL (conditional select), CSINC (conditional increment) instead of branches. Prevents timing attacks but still quantum-vulnerable if using RSA/ECC.",
      "confidence": 0.8,
      "source": "ARM_Timing_Attack_Defense",
      "keywords": ["CSEL", "CSINC", "CSINV", "constant-time"],
      "architectures": ["ARMv8"],
      "severity": "info",
      "note": "Good practice but check underlying algorithm"
    },
    {
      "type": "string_constant",
      "category": "ARM_Crypto_Strings",
      "content": "ARM crypto algorithm strings: 'RSA', 'ECDSA', 'secp256r1', 'Ed25519', 'X25519' in .rodata or .text. String references reveal algorithm choices.",
      "confidence": 0.8,
      "source": "ARM_String_Analysis",
      "keywords": ["RSA", "ECDSA", "secp256r1", "Ed25519", "X25519", "Curve25519"],
      "architectures": ["ARM", "all"],
      "severity": "medium"
    }
  ]
}
